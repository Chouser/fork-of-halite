expr         = lambda
lambda       = conditional | params <'->'> expr
params       = symbol      | <'('> (symbol (<','> symbol)* <','>? )? <')'>

conditional  = implication | ('if' | 'ifValue') <'('> conditional <')'> conditional <'else'> conditional
implication  = or          | or <'=>'> conditional
or           = and         | or '||' and
and          = equality    | and '&&' equality
equality     = relational  | relational ('==' | '!=') relational
relational   = add         | relational ('<' | '<=' | '>=' | '>') add
add          = mult        | add ('+' | '-') mult
mult         = prefix      | mult ('*' | '/' | '%') prefix
prefix       = postfix     | '!' prefix

<postfix>    = primary | get-field | get-index | AE | call-fn | type-method | call-method
get-field    = postfix <'.'> symbol
get-index    = postfix <'['> expr <']'>
AE           = ('A' | 'E') <'('> symbol <'in'> expr <')'> expr
call-fn      = symbol <'('> (expr (<','> expr)* <','>? )? <')'>
type-method  = postfix <'.'> ( 'refineTo' | 'refinesTo?' ) <'('> typename <')'>
call-method  = postfix <'.'> symbol <'('> (expr (<','> expr)* <','>? )? <')'>

<primary>    = int | symbol | string | map | set | vec | let | <'('> expr <')'>
map          = <'{'> ( map-entry ( <','> map-entry )* <','>? )? <'}'>
map-entry    = '$type' <':'> typename | symbol <':'> expr
set          = <'#{'> ( expr ( <','> expr )* <','>? )? <'}'>
vec          = <'['> ( expr ( <','> expr )* <','>? )? <']'>
let          = <'{'> ( symbol <'='> expr <';'> )* expr <'}'>
int          = "-"? #"\d+"
symbol       = #"[a-zA-Z][a-zA-Z0-9_$?]*" | #"<\S+>"
typename     = #"[a-zA-Z0-9./$]+" | symbol
string       = #"\"([^\"\\]|\\.)*\""
